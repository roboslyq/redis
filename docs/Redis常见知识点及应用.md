# 1、缓存

- 缓存优点
- 缓存数据类型
- 缓存持久化
- 缓存架构
- 缓存穿透
- 缓存雪崩



 # 2、分布式锁
 # 3、异步队列

# 4、延迟队列

# 5、管道PipeLine

# 6、Redis 通信协议RESP

Redis服务器与客户端通过RESP（REdis Serialization Protocol）协议通信。它是一种直观的文本协议，优势在于实现异常简单，解析性能极好。

为何要设计这种浪费流量的文本协议？

Redis 的设计者认为数据库的瓶颈一般不在于网络流量，而是数据库自身内部逻辑处理上。Redis 将所有数据都放在内存，用一个单线程对外提供服务，单个节点在跑满一个 CPU 核心的情况下可以达到了 10w/s 的超高 QPS。

RESP传输的最小单元类型

    单行字符串： 以 + 符号开头
    多行字符串 以 $ 符号开头，后跟字符串长度
    整数值 以 : 符号开头，后跟整数的字符串形式
    错误消息 以 - 符号开头
    数组 以 * 号开头，后跟数组的长度

注：每个单元结束时统一加上回车换行符号\r\n

    #单行字符串 hello
    +hello\r\n
    #多行字符串 hello，也支持表示单行字符串
    $11\r\nhello\r\n
    #NULL 用多行字符串表示，不过长度要写成-1
    $-1\r\n
    #空串 用多行字符串表示，长度填 0（因为两个\r\n之间,隔的是空串）
    $0\r\n\r\n
    #整数 1024
    :1024\r\n
    #错误 参数类型错误（错误消息不需要\r\n结尾）
    -WRONGTYPE unknown command
    #数组 [1,2,3]
    *3\r\n:1\r\n:2\r\n:3\r\n

>  https://redis.io/topics/protocol



# Redis线程模型？

> Redis 6 多线程模型

# Redis RESP协议

> Redis6 RESP 3

Redis

# Redis 源码中ASAP是什么意思？

As soon as possible

# Redis有哪些场景会fork子进程？

AOF

RDB

MOduble

scripting

# Redis 哪些场景会创建子线程？

1、AOF

2、lazyfree

3、replication

#　内存相关

- VSS- Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）
- RSS- Resident Set Size 实际使用物理内存（包含共享库占用的内存）
- PSS- Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存）
- USS- Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）
  一般来说内存占用大小有如下规律：VSS >= RSS >= PSS >= USS

为了简化描述，以下内存将以“页”的形式来表示，而不是“字节”。像我们的Linux系统内存管理中最低级别的页有4096 字节。

**VSS** (reported as VSZ from ps) 是一个进程总共可访问的地址空间。其大小还包括了可能不在RAM中的内存（比如虽然malloc分配了空间，但尚未写入）。 VSS 很少被用于判断一个进程的真实内存使用量。

**RSS** 是一个进程在RAM中真实存储的总内存。但是RSS还是可能会造成误导，因为它仅仅表示该进程所使用的所有共享库的大小，它不管有多少个进程使用该共享库，该共享库仅被加载到内存一次。所以RSS并不能准确反映单进程的内存占用情况。 

**PSS** 与RSS不同，它按比例表示使用的共享库， 例如：如果有三个进程都使用了一个共享库，共占用了30页内存。那么PSS将认为每个进程分别占用该共享库10页的大小。 PSS是非常有用的数据，因为系统中所有进程的PSS都相加的话，就刚好反映了系统中的总共占用的内存。 而当一个进程被销毁之后， 其占用的共享库那部分比例的PSS，将会再次按比例分配给余下使用该库的进程。这样PSS可能会造成一点的误导，因为当一个进程被销毁后，PSS不能准确地表示返回给全局系统的内存（the memory returned to the overall system）。

**USS** 是一个进程所占用的私有内存。即该进程独占的内存。 USS是非常非常有用的数据，因为它反映了运行一个特定进程真实的边际成本（增量成本）。当一个进程被销毁后，USS是真实返回给系统的内存。当进程中存在一个可疑的内存泄露时，USS是最佳观察数据。